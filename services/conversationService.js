// services/conversationService.js

/**
 * Servicio principal de gesti√≥n conversacional para Ana IA
 * Mantiene el contexto, la coherencia y la continuidad de las conversaciones
 */

import { getChatCompletion } from './openaiService.js';
import cacheService from './cacheService.js';
import realTimeProximityService from './realTimeProximityService.js';

// Estados conversacionales posibles
export const CONVERSATION_STATES = {
  GREETING: 'greeting',
  PROBLEM_REPORTING: 'problem_reporting',
  INFORMATION_SEEKING: 'information_seeking',
  BOOKING_ASSISTANCE: 'booking_assistance',
  COMPLAINT_HANDLING: 'complaint_handling',
  GENERAL_CHAT: 'general_chat',
  FOLLOWUP: 'followup'
};

// Intenciones del usuario detectadas
export const USER_INTENTIONS = {
  GREETING: 'greeting',
  COMPLAINT: 'complaint',
  QUESTION: 'question',
  REQUEST_INFO: 'request_info',
  BOOKING: 'booking',
  EMERGENCY: 'emergency',
  LOCATION_QUERY: 'location_query',
  WEATHER_QUERY: 'weather_query',
  FLIGHT_QUERY: 'flight_query',
  FOLLOWUP: 'followup',
  CLARIFICATION: 'clarification'
};

/**
 * Clase principal para manejar conversaciones
 */
class ConversationManager {
  constructor() {
    this.conversations = new Map(); // En memoria, en producci√≥n usar Redis
    this.maxHistoryLength = 20; // M√°ximo de mensajes a recordar
  }

  /**
   * Obtiene o crea una sesi√≥n de conversaci√≥n
   */
  getOrCreateSession(sessionId, userLocation = null) {
    if (!this.conversations.has(sessionId)) {
      this.conversations.set(sessionId, {
        id: sessionId,
        startTime: new Date(),
        lastActivity: new Date(),
        state: CONVERSATION_STATES.GREETING,
        context: {
          userLocation,
          currentTopic: null,
          pendingActions: [],
          userData: {},
          activeFlows: {}
        },
        history: [],
        intentions: [],
        emotions: []
      });
    }
    
    return this.conversations.get(sessionId);
  }

  /**
   * Analiza la intenci√≥n del usuario usando GPT-4o
   */
  async analyzeUserIntention(message, conversationContext) {
    const prompt = `
Analiza este mensaje del usuario y determina su intenci√≥n principal.

Contexto de la conversaci√≥n:
- Estado actual: ${conversationContext.state}
- Tema actual: ${conversationContext.context.currentTopic || 'Ninguno'}
- √öltimas 3 interacciones: ${conversationContext.history.slice(-3).map(h => `${h.role}: ${h.content}`).join('\n')}

Mensaje del usuario: "${message}"

Devuelve un JSON con:
{
  "intention": "una de: greeting, complaint, question, request_info, booking, emergency, location_query, weather_query, flight_query, followup, clarification",
  "confidence": n√∫mero entre 0 y 1,
  "topic": "tema espec√≠fico del mensaje",
  "emotion": "emoci√≥n detectada: neutral, happy, frustrated, angry, confused, excited",
  "needsFollowup": boolean,
  "contextualRelevance": "c√≥mo se relaciona con la conversaci√≥n anterior"
}
`;

    try {
      const response = await getChatCompletion([
        { role: 'system', content: prompt },
        { role: 'user', content: message }
      ], 0.3);

      return JSON.parse(response);
    } catch (error) {
      console.error('Error analizando intenci√≥n:', error);
      return {
        intention: USER_INTENTIONS.GENERAL_CHAT,
        confidence: 0.5,
        topic: 'general',
        emotion: 'neutral',
        needsFollowup: false,
        contextualRelevance: 'low'
      };
    }
  }

  /**
   * Genera una respuesta contextual usando GPT-4o
   */
  async generateContextualResponse(session, userMessage, intention, availableData = {}) {
    const systemPrompt = this.buildSystemPrompt(session, intention, availableData);
    
    const conversationHistory = [
      { role: 'system', content: systemPrompt },
      ...session.history.slice(-10), // √öltimos 10 mensajes para contexto
      { role: 'user', content: userMessage }
    ];

    const response = await getChatCompletion(conversationHistory, 0.7);
    return response;
  }

  /**
   * Construye el prompt del sistema basado en el contexto
   */
  buildSystemPrompt(session, intention, availableData) {
    const basePrompt = `
Eres Ana, una asistente tur√≠stica IA para Colombia. Eres emp√°tica, inteligente y mantienes conversaciones naturales.

CONTEXTO ACTUAL:
- Estado de conversaci√≥n: ${session.state}
- Tema actual: ${session.context.currentTopic || 'Ninguno'}
- Intenci√≥n detectada: ${intention.intention}
- Emoci√≥n del usuario: ${intention.emotion}
- Ubicaci√≥n del usuario: ${session.context.userLocation?.city || 'No especificada'}

REGLAS IMPORTANTES:
1. MANT√âN EL CONTEXTO: No saludes de nuevo si ya iniciaron la conversaci√≥n
2. S√â COHERENTE: Contin√∫a el hilo de la conversaci√≥n anterior
3. S√â EMP√ÅTICA: Responde apropiadamente a la emoci√≥n del usuario
4. NO REPITAS: Evita dar la misma informaci√≥n dos veces
5. PROFUNDIZA: Si hay un problema, ayuda a resolverlo completamente

`;

    // Agregar informaci√≥n espec√≠fica seg√∫n la intenci√≥n
    switch (intention.intention) {
      case USER_INTENTIONS.COMPLAINT:
        return basePrompt + `
SITUACI√ìN: El usuario tiene una queja o problema.
- Muestra empat√≠a genuina
- Profundiza en el problema
- Ofrece soluciones concretas
- Pregunta por evidencia si es relevante
- No cambies de tema hasta resolver o ayudar completamente
`;

      case USER_INTENTIONS.FOLLOWUP:
        return basePrompt + `
SITUACI√ìN: El usuario est√° siguiendo una conversaci√≥n anterior.
- Mant√©n la continuidad del tema
- Recuerda lo que se discuti√≥ antes
- Profundiza o avanza seg√∫n sea necesario
- No reinicies la conversaci√≥n
`;

      case USER_INTENTIONS.REQUEST_INFO:
        return basePrompt + `
SITUACI√ìN: El usuario busca informaci√≥n espec√≠fica.
- Proporciona informaci√≥n precisa y √∫til
- Usa los datos disponibles: ${JSON.stringify(availableData, null, 2)}
- Ofrece seguimiento relacionado
- Mant√©n la conversaci√≥n interactiva
`;

      default:
        return basePrompt + `
DATOS DISPONIBLES: ${JSON.stringify(availableData, null, 2)}
Responde de manera natural y √∫til seg√∫n el contexto.
`;
    }
  }

  /**
   * Actualiza el estado de la conversaci√≥n
   */
  updateConversationState(sessionId, newState, topic = null, pendingActions = []) {
    const session = this.getOrCreateSession(sessionId);
    session.state = newState;
    session.context.currentTopic = topic;
    session.context.pendingActions = pendingActions;
    session.lastActivity = new Date();
  }

  /**
   * A√±ade un mensaje al historial
   */
  addToHistory(sessionId, role, content, metadata = {}) {
    const session = this.getOrCreateSession(sessionId);
    
    session.history.push({
      role,
      content,
      timestamp: new Date(),
      metadata
    });

    // Mantener solo los √∫ltimos N mensajes
    if (session.history.length > this.maxHistoryLength) {
      session.history = session.history.slice(-this.maxHistoryLength);
    }
  }

  /**
   * Determina si necesita datos externos bas√°ndose en el mensaje del usuario
   */
  async determineDataNeeds(userMessage, intention = null, conversationContext = null) {
    // Validar que userMessage sea una string
    if (!userMessage || typeof userMessage !== 'string') {
      console.log('‚ö†Ô∏è userMessage no es una string v√°lida:', typeof userMessage, userMessage);
      return {
        location: false,
        weather: false,
        places: false,
        flights: false,
        business: false
      };
    }

    const dataNeeds = {
      location: false,
      weather: false,
      places: false,
      flights: false,
      business: false
    };

    const lowerMessage = userMessage.toLowerCase();
    console.log(`üîç Analizando mensaje para necesidades de datos: "${userMessage}"`);

    // Si no se proporciona intenci√≥n, intentar detectarla autom√°ticamente
    if (!intention && conversationContext) {
      try {
        const detectedIntention = await this.analyzeUserIntention(userMessage, conversationContext);
        intention = detectedIntention;
        console.log(`üéØ Intenci√≥n detectada autom√°ticamente:`, intention);
      } catch (error) {
        console.log('‚ö†Ô∏è No se pudo detectar intenci√≥n autom√°ticamente:', error.message);
      }
    }

    // üå§Ô∏è DETECCI√ìN AUTOM√ÅTICA DE CONSULTAS DE CLIMA
    const weatherKeywords = [
      'clima', 'tiempo', 'temperatura', 'lluvia', 'sol', 'nublado',
      'weather', 'temperature', 'rain', 'sunny', 'cloudy',
      'calor', 'fr√≠o', 'frio', 'humedad', 'viento', 'pron√≥stico', 'pronostico',
      'hot', 'cold', 'humidity', 'wind', 'forecast',
      'grados', 'celsius', 'fahrenheit', 'despejado', 'tormentoso'
    ];

    const weatherPhrases = [
      'c√≥mo est√° el clima', 'como est√° el clima', 'como esta el clima',
      'qu√© tiempo hace', 'que tiempo hace', 'c√≥mo estar√° el tiempo',
      'como estar√° el tiempo', 'como estara el tiempo',
      'va a llover', 'est√° lloviendo', 'esta lloviendo',
      'clima de hoy', 'tiempo de hoy', 'temperatura de hoy',
      'clima ma√±ana', 'tiempo ma√±ana', 'temperatura ma√±ana',
      'pron√≥stico del tiempo', 'pronostico del tiempo',
      'hace calor', 'hace fr√≠o', 'hace frio', 'est√° soleado',
      'est√° nublado', 'esta nublado', 'hay viento'
    ];

    const hasWeatherKeywords = weatherKeywords.some(keyword => lowerMessage.includes(keyword));
    const hasWeatherPhrases = weatherPhrases.some(phrase => lowerMessage.includes(phrase));

    if (hasWeatherKeywords || hasWeatherPhrases) {
      dataNeeds.weather = true;
      dataNeeds.location = true;
      console.log('üå§Ô∏è Consulta de clima detectada autom√°ticamente');
    }

    // üöÄ DETECCI√ìN DE CONSULTAS EN TIEMPO REAL Y PROXIMIDAD
    const realTimeAnalysis = realTimeProximityService.analyzeRealTimeProximityQuery(userMessage);
    
    if (realTimeAnalysis.isRealTimeProximityQuery || realTimeAnalysis.isProximityQuery) {
      dataNeeds.places = true;
      dataNeeds.location = true;
      dataNeeds.realTimeProximity = realTimeAnalysis; // Agregar an√°lisis espec√≠fico
      console.log('üöÄ Consulta en tiempo real/proximidad detectada:', {
        isRealTime: realTimeAnalysis.isRealTimeQuery,
        isProximity: realTimeAnalysis.isProximityQuery,
        category: realTimeAnalysis.category,
        urgency: realTimeAnalysis.urgency,
        confidence: realTimeAnalysis.confidence
      });
    }

    // üõ©Ô∏è DETECCI√ìN AUTOM√ÅTICA DE CONSULTAS DE VUELOS
    const flightKeywords = [
      'vuelo', 'vuelos', 'volar', 'avi√≥n', 'aerol√≠nea', 'aerolinea',
      'flight', 'flights', 'fly', 'airplane', 'airline',
      'boleto', 'pasaje', 'ticket', 'tiquete',
      'aeropuerto', 'airport', 'aterrizar', 'despegar',
      'bogot√°', 'medell√≠n', 'cali', 'barranquilla', 'bucaramanga', // ciudades frecuentes
      'ctg', 'bog', 'mde', 'clo', 'baq', 'bue' // c√≥digos de aeropuerto
    ];

    const flightPhrases = [
      'busco vuelo', 'necesito vuelo', 'quiero volar', 'buscar vuelo',
      'precio de vuelo', 'costo de vuelo', 'vuelo barato',
      'ir a bogot√°', 'viajar a', 'ir en avi√≥n',
      'de cartagena a', 'desde cartagena'
    ];

    const hasFlightKeywords = flightKeywords.some(keyword => lowerMessage.includes(keyword));
    const hasFlightPhrases = flightPhrases.some(phrase => lowerMessage.includes(phrase));

    if (hasFlightKeywords || hasFlightPhrases) {
      dataNeeds.flights = true;
      console.log('üõ©Ô∏è Consulta de vuelos detectada autom√°ticamente');
    }

    // Procesar intenci√≥n si est√° disponible
    const intentionType = intention?.intention || intention;
    
    switch (intentionType) {
      case USER_INTENTIONS.LOCATION_QUERY:
        dataNeeds.location = true;
        break;
      case USER_INTENTIONS.WEATHER_QUERY:
        dataNeeds.weather = true;
        dataNeeds.location = true;
        break;
      case USER_INTENTIONS.FLIGHT_QUERY:
        dataNeeds.flights = true;
        break;
      case USER_INTENTIONS.REQUEST_INFO:
        // Detectar consultas geogr√°ficas para todos los tipos de lugares tur√≠sticos
        const geoKeywords = {
          // Alojamiento
          hotels: ['hotel', 'hoteles', 'alojamiento', 'hospedaje', 'dormir', 'hostal', 'hostales', 'posada', 'resort'],
          // Gastronom√≠a
          restaurants: ['restaurante', 'restaurantes', 'comida', 'comer', 'almorzar', 'cenar', 'donde comer', 'gastronom'],
          // Caf√©s y bebidas
          cafes: ['caf√©', 'cafes', 'cafeter√≠a', 'cafeteria', 'coffee', 'desayunar'],
          // Bares y vida nocturna
          bars: ['bar', 'bares', 'trago', 'cerveza', 'cocktail', 'coctel', 'cantina', 'pub'],
          nightlife: ['discoteca', 'discotecas', 'rumba', 'fiesta', 'bailar', 'vida nocturna', 'club nocturno'],
          // Entretenimiento y cultura
          museums: ['museo', 'museos', 'arte', 'cultura', 'exposici√≥n', 'galer√≠a'],
          attractions: ['tur√≠stica', 'tur√≠stico', 'atracci√≥n', 'atracciones', 'visitar', 'conocer', 'ver', 'sitio', 'lugar'],
          // Compras
          shopping: ['tienda', 'tiendas', 'compra', 'comprar', 'shopping', 'centro comercial', 'mall'],
          // Servicios
          banks: ['banco', 'bancos', 'atm', 'cajero', 'dinero'],
          pharmacies: ['farmacia', 'farmacias', 'medicina', 'medicamento'],
          gas_stations: ['gasolina', 'combustible', 'gasolinera', 'estaci√≥n de servicio'],
          // Naturaleza y aire libre
          parks: ['parque', 'parques', 'naturaleza', 'verde', 'jard√≠n', 'plaza'],
          beaches: ['playa', 'playas', 'mar', 'costa', 'arena'],
          // Transporte
          transport: ['transporte', 'bus', 'taxi', 'terminal', 'aeropuerto']
        };

        // Verificar si el mensaje contiene palabras clave geogr√°ficas
        const containsGeoKeywords = Object.values(geoKeywords).some(keywords =>
          keywords.some(keyword => lowerMessage.includes(keyword))
        );

        // Tambi√©n detectar frases que indican b√∫squeda geogr√°fica
        const geoPhases = [
          'cerca de', 'cerca', 'aqu√≠', 'en esta zona', 'en esta √°rea', 
          'en este lugar', 'por aqu√≠', 'alrededor', 'en cartagena', 
          'en bogot√°', 'en medell√≠n', 'en cali', 'en esta ciudad',
          'qu√© hay', 'que hay', 'd√≥nde', 'donde', 'recomienda',
          'recomendaciones', 'sugerencias'
        ];

        const containsGeoPhases = geoPhases.some(phrase => lowerMessage.includes(phrase));

        if (containsGeoKeywords || containsGeoPhases) {
          dataNeeds.places = true;
          dataNeeds.business = true;
        }
        
        // Tambi√©n verificar el contexto conversacional
        const currentTopic = conversationContext?.currentTopic;
        if (currentTopic && Object.values(geoKeywords).some(keywords =>
          keywords.some(keyword => currentTopic.toLowerCase().includes(keyword))
        )) {
          dataNeeds.places = true;
          dataNeeds.business = true;
        }
        break;
    }

    console.log('üìä Necesidades de datos determinadas:', dataNeeds);
    return dataNeeds;
  }

  /**
   * Limpia sesiones antiguas
   */
  cleanupOldSessions(maxAge = 24 * 60 * 60 * 1000) { // 24 horas
    const now = new Date();
    for (const [sessionId, session] of this.conversations) {
      if (now - session.lastActivity > maxAge) {
        this.conversations.delete(sessionId);
      }
    }
  }
}

// Instancia global del gestor de conversaciones
export const conversationManager = new ConversationManager();

export default conversationManager;
